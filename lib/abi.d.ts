import { Data, Address, LogTopic } from './types';
export declare const T: {
    address: "address";
    addressArray: "address[]";
    uint16Array: "uint16[]";
    uint256Array: "uint256[]";
    stringArray: "string[]";
    string: "string";
    bool: "bool";
    uint8: "uint8";
    uint16: "uint16";
    uint32: "uint32";
    uint48: "uint48";
    uint64: "uint64";
    uint128: "uint128";
    uint256: "uint256";
    int8: "int8";
    int16: "int16";
    int32: "int32";
    int48: "int48";
    int64: "int64";
    int128: "int128";
    int256: "int256";
    bytes32: "bytes32";
    uint: "uint256";
    Array<X extends string>(x: X): `${X}[]`;
};
declare function toBigInt(val: string): bigint;
declare const Decoder: {
    string(val: string): string;
    address(val: string): Address;
    'uint16[]'(val: string[]): bigint[];
    'uint256[]'(val: string[]): bigint[];
    'address[]'(val: string[]): Address[];
    'string[]'(val: string[]): string[];
    uint8: typeof toBigInt;
    uint16: typeof toBigInt;
    uint32: typeof toBigInt;
    uint48: typeof toBigInt;
    uint64: typeof toBigInt;
    uint128: typeof toBigInt;
    uint256: typeof toBigInt;
    bytes32: typeof toBigInt;
    bool(val: boolean): boolean;
};
export declare type AbiType = keyof typeof Decoder;
export declare type DecodedType<T extends AbiType> = ReturnType<typeof Decoder[T]>;
export declare type DecodedTuple<TupleType> = {
    [k in keyof TupleType]: TupleType[k] extends AbiType ? DecodedType<TupleType[k]> : never;
};
export declare function abiDecode<T extends AbiType[]>(types: T, data: Data): any[];
export declare function decodeObject<Spec>(spec: Spec, data: Data): DecodedTuple<Spec>;
export declare function encodeObject<Spec>(spec: Spec, value: DecodedTuple<Spec>): Data;
export declare function encodeTopic<T extends AbiType>(t: T, v: DecodedType<T>): LogTopic;
export {};
